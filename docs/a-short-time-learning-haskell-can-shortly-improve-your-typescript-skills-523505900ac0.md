# çŸ­æ—¶é—´å­¦ä¹  Haskell å¯ä»¥å¾ˆå¿«æé«˜æ‚¨çš„æ‰“å­—æŠ€èƒ½ï¼

> åŸæ–‡ï¼š<https://itnext.io/a-short-time-learning-haskell-can-shortly-improve-your-typescript-skills-523505900ac0?source=collection_archive---------1----------------------->

![](img/fccfd0c2ab3e34f44332593a5c262b92.png)

å‡ å‘¨å‰ï¼Œæˆ‘å†³å®šæŒ‘æˆ˜è‡ªå·±å­¦ä¹  Haskell **ã€‚**æˆ‘çš„åŠ¨æœºæ˜¯æ›´å¥½åœ°æŒæ¡åŠŸèƒ½æ¨¡å¼ã€‚(è¿™æ ·çš„**å‡½å­**æˆ–è€…**å•å­**è¿™é‡Œè¿˜æœ‰å¾ˆå¤šâ†’ [**æ¨¡å¼åº“**](https://github.com/thma/LtuPatternFactory#the-patternopedia) )ã€‚åœ¨ Haskell çš„ä¸€è¡Œä»£ç ä¸­ï¼Œä½ å¯ä»¥æè¿°æŠ½è±¡çš„æ¦‚å¿µâ€”â€”è¿™æ˜¯éå¸¸å¼ºå¤§çš„ã€‚

Haskell ä¸åŒäºæˆ‘æ‰€ç†Ÿæ‚‰çš„å…¶ä»–è¯­è¨€ã€‚ä½†æˆ‘æœ€ç»ˆè¿˜æ˜¯æƒ³å‡ºäº†ä¸€ä¸ªåœ¨ TS ä¸­å®ç°ä»¿å‡½æ•°çš„å°è¯•ï¼Œæˆ‘ç§°ä¹‹ä¸º [**ã€åˆ—è¡¨ä»¿å‡½æ•°ã€‘**](https://stackblitz.com/edit/functor-explained) **ã€‚**ä½ å¯ä»¥åœ¨æˆ‘çš„[ä¸Šä¸€ç¯‡](http://degoes.net/articles/fp-glossary)ä¸Šæ‰¾åˆ°è§£é‡Šã€‚é¡ºä¾¿çœ‹çœ‹ä¸‹é¢è¿™ä¸ªä»¤äººå°è±¡æ·±åˆ»çš„é¡¹ç›® [**fp-ts**](https://github.com/gcanti/fp-ts/blob/master/src/Functor.ts) ã€‚

![](img/b97bf819c57f43b47a0ed7ddcb364c0c.png)

## é‚£ä¹ˆï¼Œå­¦ä¹ ä¸€é—¨çº¯å‡½æ•°å¼è¯­è¨€å¦‚ä½•æ”¹è¿›æ‚¨åœ¨ Typescript ä¸­çš„æ€ç»´æ–¹å¼å‘¢ï¼Ÿ

> åœ¨çº¯ç²¹çš„å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œä½ ä¸å‘Šè¯‰è®¡ç®—æœºåšä»€ä¹ˆï¼Œè€Œæ˜¯å‘Šè¯‰å®ƒä»€ä¹ˆä¸œè¥¿æ˜¯ã€‚

## ä»»ä½•ä¸œè¥¿éƒ½å¯ä»¥è¢«è¾“å…¥ï¼Œè®©æˆ‘ä»¬é‡æ–°è€ƒè™‘ä¸€ä¸‹æˆ‘ä»¬çš„åŠŸèƒ½:

å­¦ä¹  Haskell å¾ˆçŸ­çš„æ—¶é—´ï¼Œä½ å°±ä¼šå¼€å§‹åˆ°å¤„çœ‹åˆ°ç±»å‹ã€‚æˆ‘ç«‹å³å¼€å§‹åœ¨æˆ‘å†™çš„ä»»ä½• TS å‡½æ•°ä¸Šå¯»æ‰¾ç±»å‹æ¨¡å¼ã€‚

è®©æˆ‘ä»¬æ¢ç´¢ä¸‹é¢çš„ Haskell ç‰‡æ®µ:

```
add **:: Integer -> Integer -> Integer** *--function declaration* add x y =  x **+** y                       *--function definition*
```

**add** å‡½æ•°å£°æ˜çš„**ç±»å‹ä¸º:**æ•´æ•°ï¼Œå¦ä¸€ä¸ªæ•´æ•°è¾“å‡ºä¸¤ä¸ªæ•´æ•°ä¸­çš„ä¸€éƒ¨åˆ†ã€‚

åœ¨ TS ä¸­ï¼Œå®ƒå°†æ˜¯:

```
**type** Add = (a: **number**, b: **number**) => **number**; *// type signature* **export const** *add*: Add = (num1, num2) => num1 + num2;
*add*(**'foo'**, 1); *// type error
add*(2, 1); *// boom*
```

ä½ å¯ä»¥è®¿é—®ä¸‹é¢çš„ TS [playground](https://www.typescriptlang.org/play/index.html?e=26#example/typing-functions) è®°å½•å‡½æ•°å½¢çŠ¶çš„ä¾‹å­ï¼

## å°†ç±»å‹è§†ä¸ºå˜é‡ç»™æˆ‘ä»¬å¸¦æ¥äº†çµæ´»æ€§

åœ¨ Haskell ä¸­ï¼Œ**ç±»å‹å˜é‡**ç±»ä¼¼äº**æ³›å‹**(ç”±**å°å†™å­—æ¯**å®šä¹‰)ã€‚

ä»¥ä¸‹ä»£ç ç‰‡æ®µè¡¨ç¤ºå…ƒç»„çš„ç¬¬ä¸€ä¸ªé¡¹**:**

```
first :: (a, b) -> a
```

å˜é‡' **a** 'å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚

åœ¨ typescript ä¸­ï¼Œå®ƒå¯èƒ½çœ‹èµ·æ¥åƒ:

```
**type** first = <T, X> ([a, b]: [T, X]) =>  T
**const** *fst*: first = ([a, b]) => a;
***console***.log(*fst*([**'foo'**, 666]));
```

å¦‚æœæˆ‘ä»¬è¦æè¿°ä¸€ä¸ªæ›´å¤æ‚çš„å‡½æ•°ï¼Œæ¯”å¦‚ **map()** å‡½æ•°ï¼Œå®ƒçœ‹èµ·æ¥ä¼šåƒ:

```
map(transformFn: <T, V> (arg: T) => V ): MyFunctorContext<T> {
    **const** newItems = [];

    **for** (**const** item **of this**.**items**) {
        newItems.push(transformFn(item));
    }

    **return new** MyFunctorContext(newItems);
}
```

æ”¾å¤§**å˜å‹å™¨ Fn** ç±»å‹æè¿°:

```
<T, V> (arg: T) => V 
```

å˜æ¢å‡½æ•°çš„**è¾“å…¥**å¯ä»¥æ˜¯ä»»ä½•ç±»å‹(T)ã€‚å› æ­¤ï¼Œå˜æ¢åçš„**è¾“å‡º** (V)å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œä½†ä¸åŒäºè¾“å…¥ç±»å‹ï¼

## **ç±»å‹çº¦æŸ:**

è®©æˆ‘ä»¬å…³æ³¨ä¸€ä¸‹ a ç±»å‹çš„æŸä¸ª**è¡Œä¸ºã€‚å¦‚æœæˆ‘ä»¬å°†æŸä¸ªè¡Œä¸ºåŒ…å«åœ¨ä¸€ç»„**ç±»å‹**ä¸­ï¼Œæˆ‘ä»¬å°±å¯ä»¥å®ç°ä¸€ä¸ªé€šç”¨å‡½æ•°(å¤šæ€å‡½æ•°)æ¥æ“ä½œå®ƒä»¬ã€‚**

è¯´ä¸€ä¸ªç±»å‹éœ€è¦çš„æŸä¸ª**è¡Œä¸º(æˆ–å±æ€§)**å®é™…ä¸Šæ˜¯åœ¨æ·»åŠ ç±»å‹â€œçº¦æŸâ€ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªåœ¨ TS ä¸­æ·»åŠ ç±»å‹çº¦æŸçš„ä¾‹å­:(ä½¿ç”¨â€œextendsâ€å…³é”®å­—)ã€‚

```
**interface** Instrument {
    **play**: () => **void**;
}**type** PlayFn = <I **extends** Instrument>(instruments: I[]) => **void**;**class** Guitar **implements** Instrument {
    play() {}
}

**class** Drums **implements** Instrument {
    play() {}
}

**const** *playPart*:PlayFn = (instrumets) => {
    instrumets.forEach(instrument => instrument.**play**());
};

*playPart*([**new** Guitar(), **new** Drums()]);
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œåœ¨ TS ä¸­ï¼Œçº¦æŸå¯ä»¥ä¼˜é›…åœ°æ·»åŠ åˆ°å‡½æ•°ç±»å‹çš„ä¸€è¡Œè¡¨ç¤ºä¸­:

```
**type** PlayFn = <I **extends** Instrument>(instruments: I[]) => **void**;
```

åœ¨ Haskell çš„ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨ [**ç±»å‹ç±»**](http://learnyouahaskell.com/types-and-typeclasses) **ï¼Œ**æ¥å¼•ç”¨çº¦æŸï¼Œè¿™é€šå¸¸è¢«æ¯”ä½œ**æ¥å£ã€‚**

> ç±»å‹ç±»æ˜¯ä¸€ç§å®šä¹‰æŸäº›è¡Œä¸ºçš„æ¥å£ã€‚å¦‚æœä¸€ä¸ªç±»å‹æ˜¯ typeclass çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ„å‘³ç€å®ƒ**æ”¯æŒå¹¶å®ç°äº† typeclass** æè¿°çš„è¡Œä¸ºã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ç±»å‹å˜é‡çº¦æŸçš„å•è¡Œ Haskell ç¤ºä¾‹:

```
read :: (Read a) => String -> a
```

Read æ˜¯ Haskell lang æ ‡å‡†çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒæä¾›äº†è§£æå­—ç¬¦ä¸²çš„æ“ä½œï¼Œä»¥è·å¾—å®ƒä»¬å¯èƒ½è¡¨ç¤ºçš„å€¼ã€‚

å‡½æ•° **read** çš„ç±»å‹ä¸º:[(Read a) = > String - > a]ï¼Œå®ƒå¯ä»¥æ¥å—**å®ç°**Read è¡Œä¸ºçš„ä»»ä½•ç±»å‹(â€˜aâ€™)(ä½œä¸ºçº¦æŸ)ã€‚

## é‡æ–°æ€è€ƒåŠŸèƒ½æ¨¡å¼:

å¦‚æœæ‚¨å¯¹æ¨¡å¼æ„Ÿå…´è¶£ï¼Œæ‚¨å°†ä¼šéå¸¸æ¬£èµä»¥ä¸‹èµ„æº:

[](https://github.com/thma/LtuPatternFactory#the-patternopedia) [## thma/LtuPatternFactory

### æˆ‘çš„ç¬¬ä¸€ä¸ªç¼–ç¨‹è¯­è¨€æ˜¯ Lispã€Scheme å’Œ MLã€‚å½“æˆ‘åæ¥å¼€å§‹ç”¨é¢å‘å¯¹è±¡è¯­è¨€å·¥ä½œæ—¶ï¼Œæ¯”å¦‚ C++å’Œâ€¦

github.com](https://github.com/thma/LtuPatternFactory#the-patternopedia) 

å‡½å­æ˜¯ä¸åŒç±»å‹çš„å‡½æ•°è¡¨ç¤ºï¼Œå¯ä»¥è¢«æ˜ å°„ã€‚

Haskell çš„ä»¿å‡½æ•° Typeclass å®ç°æ˜¯:

```
**class** Functor f where
fmap :: (a -> b) -> f a -> f b
```

[æˆ‘å®ç°äº†ä¸€ä¸ªâ€œåˆ—è¡¨å‡½å­â€](/recognising-functional-patterns-functors-for-dummies-2a829c875767)ï¼Œå®ƒåŒ…å«äº†â€˜æ˜ å°„â€™åŠŸèƒ½ï¼Œä½†å®ƒä»…é™äºä»»ä½•ç±»å‹çš„åˆ—è¡¨ï¼Œåˆ—è¡¨æ˜¯ä¸€ä¸ªå‡½å­å®ç°ã€‚

å¦ä¸€ä¸ªä¸æ˜¯åˆ—è¡¨çš„ä»¿å‡½æ•°å®ç°çš„ä¾‹å­æ˜¯**æˆ–è€…**ä»¿å‡½æ•°:

```
**instance Functor Maybe where  
    fmap** f (**Just** x) = **Just** (f x)  
    **fmap** f **Nothing** = **Nothing**
```

**ä¹Ÿè®¸**â€œç›’å­â€æ—¢å¯ä»¥è¿”å›æŸä¸ªå€¼ï¼Œä¹Ÿå¯ä»¥ä¸è¿”å›ä»»ä½•å€¼ã€‚

è¿™å°±æ˜¯è¿™ç¯‡æ–‡ç« çš„å…¨éƒ¨å†…å®¹ï¼Œ

æ„Ÿè°¢é˜…è¯»ï¼

å¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œä½ å¯èƒ½ä¼šå–œæ¬¢:

[](https://dev.to/lironn_h/type-thinking-p2-typeclass-p76) [## ç±»å‹æ€ç»´ğŸ¤”P2 å‹

### åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ç®€å•åœ°æ¯”è¾ƒäº†ä¸€ä¸‹:å¤šæ€æ€§-(å¤šç§å½¢å¼)â€œå¤šæ€æ€§æ˜¯æä¾›ä¸€ä¸ªå•ä¸€çš„æ¥å£ç»™â€¦

å¼€å‘åˆ°](https://dev.to/lironn_h/type-thinking-p2-typeclass-p76) 

å¹²æ¯ï¼

åˆ©ä¼¦ã€‚